<Project Sdk="Microsoft.NET.Sdk" InitialTargets="RemoveBackports">

    <PropertyGroup>
        <TargetFramework>netstandard2.1</TargetFramework>
        <ImplicitUsings>enable</ImplicitUsings>
        <Nullable>enable</Nullable>
        <LangVersion>latest</LangVersion>

        <!-- Use the HASTE_MODDING_PATH environment variable to determine where to put the file cache and game files -->
        <!-- You should set this environment variable if you have multiple projects using this template so you don't -->
        <!-- have a ton of duplicate Haste installations -->
        <HASTE_MODDING_PATH Condition="'$(HASTE_MODDING_PATH)' == ''">.haste</HASTE_MODDING_PATH>
        <BasePath>$(HASTE_MODDING_PATH)</BasePath>

        <HasteDlls Condition=" '$(HasteDlls)' == '' ">$(BasePath)/game/Haste_Data/Managed/*.dll</HasteDlls>

        <!-- We are referencing mscorlib/netstandard/etc. in the game, so disable the system framework refs -->
        <DisableImplicitFrameworkReferences>true</DisableImplicitFrameworkReferences>
        <!-- Do not generate .deps.json file (it is not needed) -->
        <GenerateDependencyFile>false</GenerateDependencyFile>
        <!-- Generate full debug files so that you can debug your mod. However you do not need to ship them with your mod -->
        <DebugType>full</DebugType>

        <!-- These are here so that we can reference them quickly later on -->
        <SteamAppId>1796470</SteamAppId>
        <UnityRuntimeFiles>Editor/Data/PlaybackEngines/LinuxStandaloneSupport/Variations/linux64_player_development_mono</UnityRuntimeFiles>
        <SteamInfoFile>steam-info.json</SteamInfoFile>
        <GameVersionFile>version.txt</GameVersionFile>
        <UnityVersionFile>.unityversion</UnityVersionFile>
        <SteamAppIdFile>steam_appid.txt</SteamAppIdFile>
    </PropertyGroup>
    <ItemGroup>
        <!-- Reference all DLLs in the game. If you do not actually use anything in a DLL,
         that DLL will not get referenced in your compiled mod, so it's fine to just reference everything.
         Private="False" means that the referenced DLLs will not get copied to the output directory. -->
        <Reference Include="$(HasteDlls)" Private="false"/>
        <!-- Harmony -->
        <!-- <Reference Include="C:\Program Files (x86)\Steam\steamapps\workshop\content\1796470\3385184093\*.dll" Private="false"/> -->
    </ItemGroup>

    <!-- MonoMod.Backports.dll is required for MonoMod to work, but adding it as a reference causes issues,
     as it contains a lot of types already included in Unity's standard library mscorlib.dll. Exclude it
     from the gHaste_daalobbed references using this snippit. (make sure to add InitialTargets="RemoveBackports" to
     the <Project> tag at the top of this file) -->
    <Target Name="RemoveBackports">
        <ItemGroup>
            <Reference Remove="@(Reference)" Condition="$([System.String]::new('%(Reference.Filename)').Contains('Backports'))"/>
        </ItemGroup>
    </Target>
    
    <!--
        ======================= HASTE SETUP TARGETS =======================
         The following targets download and set up a project-local copy of
          Haste for mod development and debugging of Haste and your mod.
        
         Yes none of this is needed if you just point the build file to a
         local copy of Haste and give up debugging but that means editing
                this file per computer/collaborator and no debug :(
        
        
                               Authored by ChiefArug
                          @chiefarug on the Haste Discord
                      Contact for information on this madness
        ===================================================================
    -->
    <Target Name="DownloadVersionInfo" Outputs="$(BasePath)/$(SteamInfoFile)">
        <!-- Steam doesn't support the way that MSBuild determines if a downloaded file is new or not, so this gets downloaded each time -->
        <!-- That is fine though as it is a tiny file -->
        <DownloadFile DestinationFolder="$(BasePath)/downloadcache" SourceUrl="https://api.steamcmd.net/v1/info/$(SteamAppId)" DestinationFileName="$(SteamInfoFile)" SkipUnchangedFiles="True"/>
        <!-- Read the lines from the file and then write them to a file in a diferent location -->
        <!-- Yes this seems stupid, but it ensures that the file modification date doesn't change unless the contents change -->
        <ReadLinesFromFile File="$(BasePath)/downloadcache/$(SteamInfoFile)">
            <Output TaskParameter="Lines" ItemName="SteamInfoJsonContents"/>
        </ReadLinesFromFile>
        <WriteLinesToFile File="$(BasePath)/$(SteamInfoFile)" WriteOnlyWhenDifferent="true" Lines="@(SteamInfoJsonContents)" Overwrite="True"/>
    </Target>
    <Target Name="DownloadDepotDownloader" Outputs="$(BasePath)/buildbin/depotdownloader/DepotDownloader">
        <MakeDir Directories="$(BasePath)/downloadcache;$(BasePath)/buildbin/depotdownloader"/>
        <Message Text="Downloading DepotDownloader"/>
        <DownloadFile DestinationFolder="$(BasePath)/downloadcache" SourceUrl="https://github.com/SteamRE/DepotDownloader/releases/download/DepotDownloader_3.4.0/DepotDownloader-linux-x64.zip">
            <Output TaskParameter="DownloadedFile" ItemName="DepotDownloaderZip"/>
        </DownloadFile>
        <Message Text="Unzipping DepotDownloader"/>
        <Unzip DestinationFolder="$(BasePath)/buildbin/depotdownloader" SourceFiles="@(DepotDownloaderZip)"/>
        <PropertyGroup>
            <DepotDownloader>$(BasePath)/buildbin/depotdownloader/DepotDownloader</DepotDownloader>
        </PropertyGroup>
    </Target>
    <!-- Will only download haste files if the steam info file changed, which usually only happens when a new version is released. -->
    <!-- It can happen for other reasons, but running depot downloader doesn't take *that* long so its fine -->
    <Target Name="DownloadHasteFiles" DependsOnTargets="DownloadVersionInfo" Inputs="$(BasePath)/$(SteamInfoFile)" Outputs="$(BasePath)/game/update_last_checked_timestamp">
        <!-- This would be part of the DependsOnTargets, however we only need to run this if the version info changed and its pointless running it otherwise. -->
        <CallTarget Targets="DownloadDepotDownloader"/>

        <!-- Run with the username if it is specified. Note this requires running with -qr at least once first! -->
        <!-- Note the use of xargs is because $(<../.steamuser) wasn't working (using it requires escaping most of the characters like so: %24%28%3C../.steamuser%29 and even that wasn't working) -->
        <!-- Timeout is 5 minutes by default, you might need to increase this -->
        <Exec Condition="Exists('.steamuser')" Command="cat ../.steamuser | xargs ../$(DepotDownloader) -app $(SteamAppId) -remember-password -dir game -username " WorkingDirectory="$(BasePath)" Timeout="300000"/>
        <!-- Run without the username if its not specified. This requires signing in each time! -->
        <Exec Condition="!Exists('.steamuser')" Command="../$(DepotDownloader) -app $(SteamAppId) -qr -dir game -remember-password" WorkingDirectory="$(BasePath)" Timeout="300000"/>
        <Message Condition="!Exists('.steamuser')" Text="Now that you have logged in once, you can specify your steam username in a .steamuser file to automatically log in next time!" Importance="high"/>
        
        <!-- This makes sure that even if the SteamInfoFile file gets updated with a non game related change, this task doesnt keep running every build. -->
        <Touch Files="$(BasePath)/game/update_last_checked_timestamp" AlwaysCreate="true"/>
        
        <!-- Extract the Unity version number from the freshly downloaded game files -->
        <!-- If your IDE shows an error here ignore it, ConsoleToMSBuild does work -->
        <Exec Command="strings $(BasePath)/game/UnityPlayer.so | grep -x -E -m 1 '[0-9]+\.[0-9]+\.[0-9a-z]+ \([0-9a-z]{12}\)'" ConsoleToMSBuild="true">
            <Output TaskParameter="ConsoleOutput" PropertyName="FullUnityVersion"/>
        </Exec>
        <!-- Split the version number into its two parts -->
        <Exec Command="echo '$(FullUnityVersion)' | grep -o -E '[0-9a-z]{12}'" ConsoleToMsBuild="true">
            <Output TaskParameter="ConsoleOutput" PropertyName="HashUnityVersion"/>
        </Exec>
        <Exec Command="echo '$(FullUnityVersion)' | grep -o -E '[0-9]+\.[0-9]+\.[0-9a-z]+'" ConsoleToMsBuild="true">
            <Output TaskParameter="ConsoleOutput" PropertyName="NumericUnityVersion"/>
        </Exec>
        <!-- Yes I know Message exists. It doesn't log into Riders output window hence why I am using Exec and echo-->
        <Exec Command="echo 'Detected Unity Version: $(NumericUnityVersion) ($(HashUnityVersion))'"/>
        
        <!-- Write Unity version to a file for consumption by other targets -->
        <WriteLinesToFile File="$(BasePath)/$(UnityVersionFile)" WriteOnlyWhenDifferent="true" Overwrite="True" Lines="$(FullUnityVersion)"/>
    </Target>
    <!-- It is VERY IMPORTANT that this specifies inputs and outputs properly cause extracting unity takes AGES -->
    <Target Name="DownloadUnityFiles" DependsOnTargets="DownloadHasteFiles"
            Inputs="$(BasePath)/$(UnityVersionFile)"
            Outputs="$(BasePath)/downloadcache/$(UnityRuntimeFiles)/Haste.x86_64">
        <!-- Read the unity version from a file and split it into its component parts -->
        <!-- We need to do this because if the DownloadHasteFiles task is skipped, these properties aren't set -->
        <Exec Command="cat $(BasePath)/$(UnityVersionFile) | grep -o -E '[0-9a-z]{12}'" ConsoleToMsBuild="true">
            <Output TaskParameter="ConsoleOutput" PropertyName="HashUnityVersion"/>
        </Exec>
        <Exec Command="cat $(BasePath)/$(UnityVersionFile) | grep -o -E '[0-9]+\.[0-9]+\.[0-9a-z]+'" ConsoleToMsBuild="true">
            <Output TaskParameter="ConsoleOutput" PropertyName="NumericUnityVersion"/>
        </Exec>
        
        <DownloadFile DestinationFolder="$(BasePath)/downloadcache" SourceUrl="https://download.unity3d.com/download_unity/$(HashUnityVersion)/LinuxEditorInstaller/Unity-$(NumericUnityVersion).tar.xz">
            <Output TaskParameter="DownloadedFile" PropertyName="UnityTarball"/>
        </DownloadFile>
        <!-- Clear out the old unity files as otherwise they may stick around -->
        <RemoveDir Directories="$(BasePath)/downloadcache/Editor" ContinueOnError="true"/>

        <!-- We need to use tar to extract .xz files as MSBuild doesn't support it yet. See https://github.com/dotnet/msbuild/issues/7944 -->
        <Exec Command="echo 'Extracting Unity. This will take a while, expect about 800000 checkpoints'"/>
        <Exec Command="tar -xmf '$(UnityTarball)' --wildcards --wildcards-match-slash --checkpoint=100000 '$(UnityRuntimeFiles)/*'" WorkingDirectory="$(BasePath)/downloadcache"/>

        <!-- Rename this folder to Haste_Data, as that is whate Haste calls it -->
        <!-- The Move task does not support directories for some reason so we use the mv command. See https://github.com/dotnet/msbuild/issues/8795 -->
        <!-- First we need to delete the old folder though. We don't fail if it doesn't delete tho, cause the directory may not exist yet -->
        <RemoveDir Directories="$(BasePath)/downloadcache/$(UnityRuntimeFiles)/Haste_Data" ContinueOnError="true"/>
        <Exec Command="mv '$(BasePath)/downloadcache/$(UnityRuntimeFiles)/Data' '$(BasePath)/downloadcache/$(UnityRuntimeFiles)/Haste_Data'"/>
        <!-- Rename the main executable. Failing to do so will cause it to be unable to find Haste_Data -->
        <Move SourceFiles="$(BasePath)/downloadcache/$(UnityRuntimeFiles)/LinuxPlayer" DestinationFiles="$(BasePath)/downloadcache/$(UnityRuntimeFiles)/Haste.x86_64"/>
    </Target>
    <!-- The inputs for this task should probably be the entire list of unity player files, but one file is hopefully fine. -->
    <!-- Only the game version is required for inputs on the Haste side, as if that doesn't change nothing else has -->
    <Target Name="PatchHasteFiles" DependsOnTargets="DownloadUnityFiles;DownloadHasteFiles"
            Inputs="$(BasePath)/downloadcache/$(UnityRuntimeFiles)/Haste.x86_64;$(BasePath)/game/$(GameVersionFile)"
            Outputs="$(BasePath)/game/$(SteamAppIdFile)">
        <!-- See https://github.com/dnSpy/dnSpy/wiki/Debugging-Unity-Games#turning-a-release-build-into-a-debug-build for what this does -->
        <ItemGroup>
            <DebugFilesToCopy Include="$(BasePath)/downloadcache/$(UnityRuntimeFiles)/**"/>
        </ItemGroup>
        <!-- Actually copy and overwrite the haste files with these new ones-->
        <Copy SourceFiles="@(DebugFilesToCopy)" DestinationFiles="@(DebugFilesToCopy->'$(BasePath)/game/%(RecursiveDir)%(Filename)%(Extension)')"/>
        <!-- Write the appid file that prevents the game from restarting itself if not launched under steam -->
        <!-- This is also used as the output file for tracking if this task needs to run, so it is ALWAYS written to -->
        <WriteLinestoFile File="$(BasePath)/game/$(SteamAppIdFile)" Lines="$(SteamAppId)" WriteOnlyWhenDifferent="False" Overwrite="True"/>
        <!-- Enable debugging by editing boot.config -->
        <WriteLinestoFile File="$(BasePath)/game/Haste_Data/boot.config" Lines="player-connection-debug=1" Overwrite="False"/>
        <WriteLinestoFile File="$(BasePath)/game/Haste_Data/boot.config" Lines="$([System.IO.File]::ReadAllText('$(BasePath)/game/Haste_Data/boot.config').Replace('wait-for-native-debugger=0','wait-for-native-debugger=1'))" Overwrite="True"/>
    </Target>

    <!-- This target exits so we can have an input of the modding path enviroment variable -->
    <Target Name="ExportModdingPath">
        <WriteLinesToFile File=".haste_modding_path" Lines="$(BasePath)" WriteOnlyWhenDifferent="true" Overwrite="true"/>
    </Target>

    <!-- Write the run configurations to the .run folder using the path that we installed the game to. -->
    <Target Name="SetupRunConfigurations" Inputs=".haste_modding_path" Outputs=".run/Launch Haste (Unity).run.xml;.run/Launch Haste (Steam).run.xml" DependsOnTargets="ExportModdingPath">
        <PropertyGroup>
            <SteamRunConfig>
                <component name="ProjectRunConfigurationManager">
                    <configuration default="false" name="Launch Haste (Steam)" type="ShConfigurationType">
                        <option name="SCRIPT_TEXT" value="steam steam://rungameid/$(SteamAppId)" />
                        <option name="INDEPENDENT_SCRIPT_PATH" value="true" />
                        <option name="SCRIPT_PATH" value="" />
                        <option name="SCRIPT_OPTIONS" value="" />
                        <option name="INDEPENDENT_SCRIPT_WORKING_DIRECTORY" value="true" />
                        <option name="SCRIPT_WORKING_DIRECTORY" value="$PROJECT_DIR$" />
                        <option name="INDEPENDENT_INTERPRETER_PATH" value="true" />
                        <option name="INTERPRETER_PATH" value="/bin/bash" />
                        <option name="INTERPRETER_OPTIONS" value="" />
                        <option name="EXECUTE_IN_TERMINAL" value="true" />
                        <option name="EXECUTE_SCRIPT_FILE" value="false" />
                        <envs />
                        <method v="2">
                            <option name="Build Solution" enabled="true" />
                        </method>
                    </configuration>
                </component>
            </SteamRunConfig>
            <DirectRunConfig>
                <component name="ProjectRunConfigurationManager">
                    <configuration default="false" name="Launch Haste (Direct)" type="RunUnityExe" factoryName="Unity Executable">
                        <log_file alias="player.log" path="$USER_HOME$/.config/unity3d/Landfall/Haste/Player.log" />
                        <option name="EXE_PATH" value="$(BasePath)/game/Haste.x86_64" />
                        <option name="WORKING_DIRECTORY" value="$(BasePath)/game" />
                        <option name="PASS_PARENT_ENVS" value="1" />
                        <option name="ENV_FILE_PATHS" value="" />
                        <option name="REDIRECT_INPUT_PATH" value="" />
                        <option name="MIXED_MODE_DEBUG" value="0" />
                        <method v="2">
                            <option name="Build Solution" enabled="true" />
                        </method>
                    </configuration>
                </component>
            </DirectRunConfig>
        </PropertyGroup>
        <MakeDir Directories=".run"/>
        <WriteLinesToFile File=".run/Launch Haste (Steam).run.xml" Lines="$(SteamRunConfig)" WriteOnlyWhenDifferent="false" Overwrite="true"/>
        <WriteLinesToFile File=".run/Launch Haste (Direct).run.xml" Lines="$(DirectRunConfig)" WriteOnlyWhenDifferent="false" Overwrite="true"/>
    </Target>

    <!-- This is a very small target thats primary purpose is to depend on PatchHasteFiles and run before the build is prepared-->
    <Target Name="Setup" DependsOnTargets="PatchHasteFiles" BeforeTargets="PrepareForBuild">
        <CallTarget Targets="SetupRunConfigurations"/>
        <Exec Command="echo Setup complete!"/>
    </Target>

    <!-- Target that deletes all files generated by this build when you run Clean -->
    <Target Name="CleanAllHasteFiles" BeforeTargets="CoreClean">
        <ItemGroup>
            <FoldersToClear Include="$(BasePath)/*"/>
        </ItemGroup>
        <RemoveDir Directories="@(FoldersToClear)" ContinueOnError="true"/>
    </Target>
</Project>
